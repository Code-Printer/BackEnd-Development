# MQ  
MQ(message quenue)消息队列，遵循FIFO先进先出机制，用于上下游的通信。  
## MQ的特点  
1、流量削峰  
对高峰时的超出系统承载的请求做缓存，再输出  
2、子系统解耦  
使子系统之间不用在有强依赖性（还是利用缓存，将未处理的消息先放到队列中），提升系统的可用性  
3、异步处理（两个任务不会阻塞，同时执行）  
比如A需要调用B的服务，但B执行时间较长，A需要B的执行结果，以往有两个方法解决，一是A提供一个callBack方法，B执行完，调用该方法通知A，二是A去轮训。现在使用消息队列，在B执行完后，只需要发条消息给MQ，A订阅MQ就可以收到处理完成的结果信息。     
## 服务引入消息队列的缺点  
1、服务的可用性降低  
2、服务的复杂性升高 
## RabbitMQ  
存储转发消息。由于erlang语言的高并发性，所以RabbitMQ的性能比较好，微秒级的时效性，可以处理数据量较少的场景   
### RabbitMQ的四大核心概念  
生产者、消费者、队列、交换机（指定接收的消息发往那个队列或丢弃）  
#### 名词介绍  
Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。
Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue。
Connection：publisher／consumer 和 broker 之间的 TCP 连接。
Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立TCPConnection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销。 
Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout(multicast)。
Queue：消息最终被送到这里等待 consumer 取走。
Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。

### 消息队列的五种消息模型  
#### 简单模型   
三个角色：生产者-队列-消费者  
#### 工作模型（任务队列）  
多个消费者轮训获取消息，一个消息只能被消费一次（可以在消费端设置信道的不公平分发prefetch，保证能者多劳，保证多个消费者不同消费能力下，保持最高的消费速率）  
#### 发布订阅模型  
消息队列会将队列的消息发送给所有订阅了该队列的消费者，实现一个消息多个消费者消费。
### 保证消息不丢失（生产者、队列、消费者）  
##### 消息应答机制  
防止消息丢失，在消费者消费完消息时，会告诉rabbitmq处理完该消息的结果。消息应答分为自动应答和手 动应答（在高吞吐量和安全性方面做衡量）。  
##### 手动应答自动会有消息补偿机制（消息重入队列）  
当前消费者出现断开连接或其他原因导致消费中断，RabbitMQ会将该消费者正在消费的消息重入到队列中，让下一个消费者消费。
##### 队列与消息的持久化  
默认MQ服务宕机后，消息与队列全部消失，可以设置队列（在创建队列时声明队列为持久化队列）与消息的持久化（发送消息时，标注该消息持久化存储）。  

##### 发布确认  
生产者将消息发送到消息队列，消息队列对生产者的确认应答机制，生产者可以在回调方法中处理应答的逻辑。
###### 单个确认发布  
是一种同步的确认发布方式，生产者只有在队列确认应答后才能发布下一条消息，吞吐量较低。  
###### 批量确认发布  
同步确认消息，可以批量确认，保证高吞吐量，但当发布消息有故障时，不确定批量中是那一条消息出现的问题。
###### 异步发布确认（既提高了发布的性能又保证了消息的可靠性）   
队列通过回调函数，将收到确认回调反方法的消息与未收到确认回调方法的消息放在信道中，发送者创建消息发布确认监听器（channel.addConfirmListener（））查看消息是否被消息队列确认    
### 消息的重复消费（同一消费者消费两次同一消息）解决方法  
导致重复消费的原因：
1、生产者在获取队列的发布确认时，由于网络原因没有收到确认消息，再次发送同一消息到该队列  
2、消费者在消费完确认应答时挂掉了，再启一个消费者时会消费同一消息。  
解决方法：
对消息的内容进行唯一性约束（比如入库时，校验消息的唯一性属性）  

### Rabbitmq的交换器
#### 交换器类型  
RabbitMQ交换器类型：direct、fanout、topic、headers；
direct交换器：全匹配路由键，只有当消息的routing key与交换器与队列的binding key值完全相等才会发送消息到binging key的指定队列；
fanout器：广播交换器，交换器会将消息发送到所有绑定了交换器上的队列；
topic交换器：模糊匹配交换器，会使用#或*进行routing key与bing key做模糊匹配，发送消息到指定的消息队列；
header交换器：使用消息的header与消息队列做匹配发送；  
### 死信队列（防止消息丢失）  
死信队列：当消息过期、被拒和队列已满将消息发送到死信队列，使用消费者监听死信队列，消费死信队列的消息。
1、可以实现过期消息的消费；（延时队列）
2、可以实现队列满之后的处理逻辑；
3、可以实现正常队列拒绝消息的逻辑处理。   
实现思想：设置正常队列的参数（死信队列交换机、路由键，有过期时间，设置队列过期时间）与死信队列连接，通过消费者监听死信队列来处理消息。  
#### 延时队列  
延时队列可以通过两种方式实现：
1、给队列设置过期时间，这样该队列中所有的消息都遵守该过期时间；
2、单独给每条消息设置过期参数，消息到时间后，自动过期（缺点：队列只会校验队列头一条消息的过期时间，如果第一条过期时间比第二条消息的过期长，只有等第一条过期后，才会检查第二条）  
#### 延时队列针对消息设定过期时间优化  
需要下载插件，放在rabbitmq工具下，使用命令使其生效。  
#### 延时队列的实现方法  
1、通过消息队列的死信队列   优点：可以利用队列的发布确认、消息应答和集群保证消息服务的可靠性（宕机下有其他集群消息队列仍可用、不丢失和一定会被消费）。  
2、redis的zset数据结构，实现延时队列   缺点：不稳定，可能丢失数据  
3、java自己的延时队列数据结构  缺点：基于内存，无法持久化，重启会丢失数据
### RabbitMQ的集群（降低消息的丢失性，增强服务的可用性）  
Rabbitmq天生支持集群  ，集群的两种模式：普通模式与镜像模式；
普通模式：在每个机器上部署一个Rabbitmq实例，但创建的quenue只会在一个实例上，，其他实例会同步这个实例quenue的元数据，当消费者连接其他实例时，其他实例会向这个实例的quenue拉取数据，当这个实例的quenue挂掉后，将不能再提供服务；
镜像模式：每个服务器上的rabbitmq实例都独立创建quenue，每个实例上quenue消息增加时或消费时都会同步到其他的实例quenue上；
同步的元数据（命名数据）：
队列元数据：队列的名称及属性；
交换器元数据：交换器的名称及属性；
binding元数据：路由绑定消息队列的数据；
vhost元数据：为队列、交换器和binding提供命名空间和安全属性的元数据。
## 实战应用场景  
### 消息的顺序消费  
多消费者或者多生产者下保证消息的有序消费：发送者对消息进行编码，每次消费消息首先看上一条消息有没有被消费过，有，就消费，没有就加入到redis的持久化缓存中，直至上一个消息被消费才再消费本条消息！
