# MQ(message queue)消息队列  
消息队列的种类：RocketMQ、Kafka、RabbitMQ、ActiveMQ...    
各种消息队列中间件的性能对比如下：  
![result](https://static01.imgkr.com/temp/3e9fc8e2aa42462f964abb53c08afb44.jpg)  

### 消息队列的核心   
消息队列的底层原理是：一发一存一消费(消息队列的作用就是转发器)  
### 消息队列的两种模型  
1、队列模型    
队列模型的队列消息按照什么顺序写进去，就按照什么顺序读出来。不过，消费者从队列中接受数据不是 “读” 这个操作，而是从队列中获取这个数据并删除。它允许多个生产者往同一个队列发送消息。但是，如果有多个消费者，则他们一定是竞争的关系，也就是一条消息只能被其中一个消费者接收到，读完即被删除。  
模型结构如下图  
![result](https://static01.imgkr.com/temp/0ba69a48fad3434c8f7a00da6ee9086e.jpg)    

2、发布-订阅模型  
如果要求每个消费者都要收到全量的消息，则可以使用发布-订阅模型。在发布-订阅模型中，存放消息的容器变成了 “主题”，订阅者在接收消息之前需要先 “订阅主题”。最终，每个订阅者都可以收到同一个主题的全量消息。仔细对比下它和 “队列模式” 的异同：在于消息的传递方式是单播还是多播。  
![result](https://static01.imgkr.com/temp/1f42850936914de19fa3ced01aa4eb8f.jpg)  

### 根据模型查看消息队列的应用场景  
MQ的应用场景：  
(1)系统解耦(1、消费者与生产者(可以理解为web的两个用户之间的通信)之间添加了队列，生产者只与队列之间存在关系，不必在乎是否存在消费者；2、使用多播的消息传递方式，使得每个消费者之间不存在联系)。  
(2)异步通信(采用多播的消息传递方式)，例如博客的热搜信息发布给每个用户。  
(3)流量削峰(把同步转换成异步消息推送(多播)，中间通过一个队列在一端承接瞬时的流量洪峰(请求)，在另一端平滑地将消息推送出去)，某一时刻请求激增，如果此时服务器接收所有请求，可能会超出服务器的承受能力，造成系统宕机，故此时可以采取消息队列，接收所有请求，输出由服务器可接受的请求数量。例如：天猫双十一用户购物。  
(4)延迟通知(队列+定时任务)。  
(5)最终一致性保证(队列的数据结构)。  
(6)顺序消息(队列的数据结构)。  

### MQ的应用场景举例  
1、远程通讯协议RPC(Remote Prouducer Call)远程过程调用模型与MQ模型的区别：  
![result](https://static01.imgkr.com/temp/6b65785f3cbe4773acdba9520c915e76.jpg)   

差异在于:   
(1)、引入MQ后，由之前的一次RPC变成了现在的两次RPC，而且生产者只跟队列耦合(解耦)，它根本无需知道消费者的存在。  
(2)、多了一个中间节点队列进行消息转储，相当于将同步变成了异步。   

2、电商业务中最常见的订单支付场景   
在订单支付成功后，需要更新订单状态、更新用户积分、通知商家有新订单、更新推荐系统中的用户画像等等。  
![result](https://static01.imgkr.com/temp/f58d56ce156b499e81dceb94dbe0afdc.jpg)
(1)引入消息队列后，订单支付现在只需要关注它最重要的流程：更新订单状态即可。其他不重要的事情全部交给消息队列来通知。达到了系统的解耦作用:改造前订单系统依赖3个外部系统，改造后仅仅依赖MQ。  
(2)后续业务再扩展也不涉及订单系统的修改(消息队列上一部分)，从而保证了核心流程的稳定性，降低了维护成本。  
(3)因为 MQ 的引入，更新用户积分、通知商家、更新用户画像这些步骤全部变成了异步执行，能减少订单支付的整体耗时，提升订单系统的吞吐量。这便是 MQ 的另一个典型应用场景：异步通信。  
### 设计一个MQ模型  
MQ通信模型可以简单的理解为两次RPC和消息转储，基本实现内容：  
1、直接利用成熟的RPC框架（Dubbo 或者 Thrift），实现两个接口：发消息和读消息。   
2、消息存放在数据库中，数据结构可以用JDK自带的 ArrayBlockingQueue。  
核心流程如下所示：   
![result](https://static01.imgkr.com/temp/ab505a87f200481ab0fc91cd9b172c37.jpg)  

基本核心为：  
1、Broker（服务端）：MQ 中最核心的部分，是 MQ 的服务端，核心逻辑几乎全在这里，它为生产者和消费者提供 RPC 接口，负责消息的存储、备份和删除，以及消费关系的维护等。  
2、Producer（生产者）：MQ 的客户端之一，调用 Broker 提供的 RPC 接口发送消息。  
3、Consumer（消费者）：MQ 的另外一个客户端，调用 Broker 提供的 RPC 接口接收消息，同时完成消费确认。  

### 设计MQ功能需求难点和非功能需求难点(重点)  
1、(功能需求)RPC通信  
解决的是Broker与Producer以及Consumer之间的通信问题。如果不重复造轮子，直接利用成熟的RPC框架Dubbo或者Thrift实现即可，这样不需要考虑服务注册与发现、负载均衡、通信协议、序列化方式等一系列问题了。当然，你也可以基于 Netty 来做底层通信，用Zookeeper、Euraka等来做注册中心，然后自定义一套新的通信协议（类似Kafka），也可以基于AMQP这种标准化的MQ协议来做实现（类似RabbitMQ）。对比直接用RPC 框架，这种方案的定制化能力和优化空间更大。  

2、(非功能需求)高可用设计  
高可用主要涉及两方面：Broker服务的高可用、存储方案的高可用。可以拆开讨论。Broker 服务的高可用，只需要保证 Broker 可水平扩展进行集群部署即可，进一步通过服务自动注册与发现、负载均衡、超时重试机制、发送和消费消息时的ack机制来保证。  
存储方案的高可用有两个思路：1）参考 Kafka 的分区 + 多副本模式，但是需要考虑分布式场景下数据复制和一致性方案（类似 Zab、Raft等协议），并实现自动故障转移；2）还可以用主流的数据库、分布式文件系统、带持久化能力的key-value系统，它们都有自己的高可用方案。  
3、(非功能需求)存储设计  
消息的存储方案是 MQ 的核心部分，可靠性保证已经在高可用设计中谈过了，可靠性要求不高的话直接用内存或者分布式缓存也可以。这里重点说一下存储的高性能如何保证？这个问题的决定因素在于存储结构的设计。目前主流的方案是：追加写日志文件（数据部分） + 索引文件的方式（很多主流的开源MQ都是这种方式），索引设计上可以考虑稠密索引或者稀疏索引，查找消息可以利用跳转表、二分查找等，还可以通过操作系统的页缓存、零拷贝等技术来提升磁盘文件的读写性能。如果不追求很高的性能，也可以考虑现成的分布式文件系统、key-value存储或者数据库方案。
4、(非功能需求)消费关系  
管理为了支持发布-订阅的广播模式，Broker需要知道每个主题都有哪些Consumer订阅了，基于这个关系进行消息投递。由于Broker是集群部署的，所以消费关系通常维护在公共存储上，可以基于Zookeeper、Apollo等配置中心来管理以及进行变更通知。
5、(非功能需求)高性能设计  
存储的高性能前面已经谈过了，当然还可以从其他方面进一步优化性能。比如 Reactor 网络 IO 模型、业务线程池的设计、生产端的批量发送、Broker端的异步刷盘、消费端的批量拉取等等。

### 使用MQ所带来的的问题及解决方案  
1、系统的异步通信所带来的数据一致性问题  
可以采用分布式事务保证数据的一致性，每个成功才提交，有一个失败都不会不提交事务。  
2、重复消费....