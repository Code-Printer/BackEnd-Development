# Redis的缓存问题  
## 缓存预热      
请求数量较高，大量的请求过来之后都要从缓存中获取数据，但是缓存中又没有，从数据库中查找数据后将数据再存入缓存，造成了短期内对redis的高强度操作。    
### 解决方案：  
为了防止用户访问的时候Redis中没有数据，所以提前将热点数据保存到Redis里面（通过LRU数据删除策略，可以得到高频数据队列），通过脚本的方式将热点数据提前加入。  
## 缓存穿透(访问的数据不存在)  
大量请求参数查询的内容是redis不存在的数据(缓存没有命中)，跳过了redis内存数据库的缓存阶段，每次都访问持久化数据库，持久化数据库中**也没有**该查询内容，导致对持久化数据库造成很大的压力。       
### 解决方案  
1、布隆过滤器：对查询参数进行合法校验。 
2、缓存null：Redis对查询结果为null的数据进行缓存，但是这种方式效果十分有限，会导致Redis中缓存了无用的null值，占用空间。
## 缓存击穿(击中一点)  
**单个高热数据**过期的瞬间，数据访问量较大，未命中redis后，发起了大量对持久化数据库访问，对数据库服务器造成压力。    
### 解决方案  
1、加大热点key的过期时长。  
2、对key加分布式锁，使得单个key同一时间只能被一个线程访问，降低数据库的访问压力。
## 缓存雪崩(一片片雪花组成)  
短时间范围内，大量key集中过期，导致全部请求对持久化数据库服务器造成压力。        
### 解决方案  
对key数据使用LRU(最近最少使用淘汰算法：距离发生替换点的时间越长就会被淘汰)与LFU(最不经常使用淘汰算法：淘汰不频繁使用的算法)淘汰策略，尽量去淘汰访问频度低的数据。   
  



